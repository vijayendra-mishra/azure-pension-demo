name: CI/CD Pipeline

# Integrated CI/CD and Release Flow
on:
  pull_request:
    branches: [ main ]
  push:
    branches: [ main ]

permissions:
  contents: write
  pull-requests: write
  id-token: write
  actions: write
  security-events: write
  deployments: write
  packages: write

jobs:
  test:
    runs-on: ubuntu-latest
    # Run tests on PRs to main, and on pushes to main only
    if: github.event_name == 'pull_request' || (github.event_name == 'push' && github.ref == 'refs/heads/main')
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: '8.0.x'
    
    - name: Restore dependencies
      run: dotnet restore PensionDemo.sln
    
    - name: Build
      run: dotnet build PensionDemo.sln --no-restore
    
    - name: Test
      run: dotnet test PensionDemo.sln --no-build --verbosity normal --collect:"XPlat Code Coverage" /p:CollectCoverage=true /p:CoverageFormat=cobertura /p:ExcludeByAttribute=Obsolete

    - name: Generate Coverage Report
      run: |
        dotnet tool install -g dotnet-reportgenerator-globaltool
        reportgenerator -reports:**/coverage.cobertura.xml -targetdir:coverage -reporttypes:"HtmlInline;JsonSummary"

    - name: Check Code Coverage Threshold (80%)
      run: |
        coverage=$(cat coverage/summary.json | grep -o '"linecoverage":[^,]*' | grep -o '[0-9.]*$')
        echo "Line Coverage: ${coverage}%"
        if (( $(echo "$coverage < 80" | bc -l) )); then
          echo "‚ùå Code coverage is ${coverage}%, below required 80%"
          exit 1
        fi
        echo "‚úÖ Code coverage is ${coverage}%, meets required 80%"

    - name: Comment PR with Coverage Report
      if: github.event_name == 'pull_request' && always()
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          const summaryFile = 'coverage/summary.json';
          
          if (fs.existsSync(summaryFile)) {
            const summary = JSON.parse(fs.readFileSync(summaryFile, 'utf8'));
            const lineCoverage = summary.linecoverage || 0;
            const branchCoverage = summary.branchcoverage || 0;
            
            const badge = lineCoverage >= 80 ? '‚úÖ' : '‚ùå';
            
            const comment = `## ${badge} Code Coverage Report\n\n| Metric | Coverage |\n|--------|----------|\n| Line Coverage | ${lineCoverage.toFixed(2)}% |\n| Branch Coverage | ${branchCoverage.toFixed(2)}% |\n| Threshold | 80% |\n\n${lineCoverage >= 80 ? '‚úÖ Coverage meets threshold' : '‚ùå Coverage below 80% threshold'}`;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });
          }

  infrastructure:
    needs: test
    runs-on: ubuntu-latest
    if: >
      github.event_name == 'push' && 
      github.ref == 'refs/heads/main' &&
      !contains(github.event.head_commit.message, 'chore(main): release')
    environment: dev
    
    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - name: Check if Terraform files changed
      id: terraform-changes
      run: |
        if git diff --name-only HEAD~1 HEAD | grep -E '^terraform/' > /dev/null; then
          echo "changed=true" >> $GITHUB_OUTPUT
        else
          echo "changed=false" >> $GITHUB_OUTPUT
        fi
    
    - name: Skip if no Terraform changes
      if: steps.terraform-changes.outputs.changed == 'false'
      run: echo "‚è≠Ô∏è  Skipping infrastructure job - no Terraform changes detected"
    
    - name: Setup Terraform
      if: steps.terraform-changes.outputs.changed == 'true'
      uses: hashicorp/setup-terraform@v2
      with:
        terraform_version: latest
    
    - name: Create .terraformrc
      if: steps.terraform-changes.outputs.changed == 'true'
      run: |
        cat > ~/.terraformrc << EOF
        credentials "app.terraform.io" {
          token = "${{ secrets.TF_API_TOKEN }}"
        }
        EOF
    
    - name: Terraform Init and Select Dev Workspace
      if: steps.terraform-changes.outputs.changed == 'true'
      run: |
        cd terraform
        terraform init -input=false -upgrade -reconfigure
      env:
        ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
        ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
        ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
        ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
        TF_WORKSPACE: azure-pension-demo-dev
    
    - name: Terraform Plan Dev
      if: steps.terraform-changes.outputs.changed == 'true'
      run: cd terraform && terraform plan -var-file=environments/dev/terraform.tfvars -out=tfplan-dev
      env:
        ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
        ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
        ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
        ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
        TF_WORKSPACE: azure-pension-demo-dev
    
    - name: Terraform Apply Dev
      if: steps.terraform-changes.outputs.changed == 'true'
      run: cd terraform && terraform apply -auto-approve tfplan-dev
      env:
        ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
        ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
        ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
        ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
        TF_WORKSPACE: azure-pension-demo-dev

  deploy-dev:
    needs: infrastructure
    runs-on: ubuntu-latest
    if: >
      github.event_name == 'push' && 
      github.ref == 'refs/heads/main' && 
      !contains(github.event.head_commit.message, 'chore(main): release') &&
      !contains(github.head_ref, 'release-please')
    environment: dev
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: '8.0.x'
    
    - name: Restore dependencies
      run: dotnet restore src/Functions/Functions.csproj
    
    - name: Build Functions
      run: dotnet build src/Functions/Functions.csproj --configuration Release
    
    - name: Publish Functions
      run: dotnet publish src/Functions/Functions.csproj --configuration Release --output ./output
    
    - name: Deploy to Azure Functions Dev
      uses: Azure/functions-action@v1
      with:
        app-name: 'vjs-pension-dev-func-2'
        package: './output'
        publish-profile: ${{ secrets.AZURE_FUNCTIONAPP_PUBLISH_PROFILE_DEV }}

  release-please:
    needs: deploy-dev
    runs-on: ubuntu-latest
    if: >
      github.event_name == 'push' && 
      github.ref == 'refs/heads/main' && 
      !contains(github.event.head_commit.message, 'chore(main): release') &&
      needs.deploy-dev.result == 'success'
    
    steps:
      - uses: actions/checkout@v4
      
      - uses: googleapis/release-please-action@v4
        with:
          token: ${{ secrets.RELEASE_PLEASE_TOKEN }}
          release-type: simple

  deploy-prod:
    needs: test
    runs-on: ubuntu-latest
    if: >
      github.event_name == 'push' && 
      github.ref == 'refs/heads/main' && 
      contains(github.event.head_commit.message, 'chore(main): release')
    environment: prod
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: '8.0.x'
    
    - name: Restore dependencies
      run: dotnet restore src/Functions/Functions.csproj
    
    - name: Build Functions
      run: dotnet build src/Functions/Functions.csproj --configuration Release
    
    - name: Publish Functions
      run: dotnet publish src/Functions/Functions.csproj --configuration Release --output ./output
    
    - name: Deploy to Azure Functions Prod
      uses: Azure/functions-action@v1
      with:
        app-name: 'vjs-pension-prod-func-2'
        package: './output'
        publish-profile: ${{ secrets.AZURE_FUNCTIONAPP_PUBLISH_PROFILE_PROD }}

  cleanup-release-branch:
    needs: deploy-prod
    runs-on: ubuntu-latest
    if: >
      github.event_name == 'push' && 
      github.ref == 'refs/heads/main' && 
      contains(github.event.head_commit.message, 'chore(main): release') &&
      needs.deploy-prod.result == 'success'
    
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.RELEASE_PLEASE_TOKEN }}
          fetch-depth: 0
      
      - name: Delete release-please branch
        run: |
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          
          # Delete ANY branch starting with "release-please"
          echo "üîç Looking for release-please branches to delete..."
          git ls-remote --heads origin | awk '/release-please/ { print $2 }' | sed 's|refs/heads/||' | while read branch; do
            if [ ! -z "$branch" ]; then
              echo "üóëÔ∏è Deleting branch: $branch"
              git push origin --delete "$branch" || echo "‚ö†Ô∏è Could not delete $branch"
            fi
          done
          
          echo "‚úÖ Cleanup complete"
