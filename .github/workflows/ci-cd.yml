name: CI/CD Pipeline

# Integrated CI/CD and Release Flow
on:
  pull_request:
    branches: [ main ]
  push:
    branches: [ main ]

permissions:
  contents: write
  pull-requests: write
  id-token: write
  actions: write
  security-events: write
  deployments: write
  packages: write

jobs:
  test:
    runs-on: ubuntu-latest
    # Run tests on PRs to main, and on pushes to main only
    if: github.event_name == 'pull_request' || (github.event_name == 'push' && github.ref == 'refs/heads/main')
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: '8.0.x'
    
    - name: Restore dependencies
      run: dotnet restore PensionDemo.sln
    
    - name: Build
      run: dotnet build PensionDemo.sln --no-restore
    
    - name: Test with Coverage
      run: |
        dotnet add src/Tests/Tests.csproj package coverlet.collector --version 6.0.0 2>/dev/null || true
        dotnet test PensionDemo.sln \
          --no-build \
          --verbosity normal \
          --collect:"XPlat Code Coverage" \
          --logger "trx;LogFileName=test-results.trx" \
          /p:CollectCoverage=true \
          /p:CoverageFormat=cobertura \
          /p:CoverageFileName=coverage.cobertura.xml \
          /p:CoverageIncludeSource=true

    - name: Generate Coverage Report
      if: always()
      run: |
        echo "üì¶ Installing ReportGenerator..."
        dotnet tool install -g dotnet-reportgenerator-globaltool --version 5.5.1 || dotnet tool update -g dotnet-reportgenerator-globaltool --version 5.5.1
        
        echo "üîç Finding coverage files..."
        find . -name "coverage.cobertura.xml" -type f
        
        echo "üìä Generating HTML coverage report..."
        mkdir -p coverage
        
        # Get all coverage files and generate report
        COVERAGE_FILES=$(find . -name "coverage.cobertura.xml" -type f | tr '\n' ';')
        
        if [ -z "$COVERAGE_FILES" ]; then
          echo "‚ùå No coverage files found! Test execution may have failed."
          ls -la src/Tests/bin/Debug/net8.0/ 2>/dev/null || echo "Tests bin directory not found"
          exit 1
        fi
        
        reportgenerator -reports:"$COVERAGE_FILES" -targetdir:coverage -reporttypes:HtmlInline,JsonSummary,Badges -verbosity:Verbose
        
        echo "‚úÖ Coverage report generated successfully"
        ls -la coverage/

    - name: Upload Coverage Artifacts
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: coverage-report
        path: coverage/
        retention-days: 30

    - name: Check Code Coverage Threshold (80%)
      if: always()
      run: |
        if [ ! -f coverage/summary.json ]; then
          echo "‚ö†Ô∏è  Coverage report not found"
          exit 1
        fi
        
        # Extract line coverage from summary.json
        coverage=$(jq '.linecoverage // 0' coverage/summary.json)
        echo "üìä Line Coverage: ${coverage}%"
        
        # Check threshold
        THRESHOLD=80
        if (( $(echo "$coverage < $THRESHOLD" | bc -l) )); then
          echo "‚ùå Code coverage ${coverage}% is below required ${THRESHOLD}%"
          exit 1
        fi
        echo "‚úÖ Code coverage ${coverage}% meets required ${THRESHOLD}% threshold"

    - name: Comment PR with Coverage Report
      if: github.event_name == 'pull_request' && always()
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          const summaryFile = 'coverage/summary.json';
          
          try {
            if (!fs.existsSync(summaryFile)) {
              console.log('Coverage report not found, skipping PR comment');
              return;
            }
            
            const summary = JSON.parse(fs.readFileSync(summaryFile, 'utf8'));
            const lineCoverage = (summary.linecoverage || 0).toFixed(2);
            const branchCoverage = (summary.branchcoverage || 0).toFixed(2);
            const threshold = 80;
            const passed = lineCoverage >= threshold;
            
            const statusEmoji = passed ? '‚úÖ' : '‚ùå';
            
            const comment = `## ${statusEmoji} Code Coverage Report\n\n| Metric | Coverage | Status |\n|--------|----------|--------|\n| Line Coverage | ${lineCoverage}% | ${lineCoverage >= threshold ? '‚úÖ Pass' : '‚ùå Fail'} |\n| Branch Coverage | ${branchCoverage}% | - |\n| Threshold | ${threshold}% | - |\n\n${passed ? '‚úÖ Coverage meets the required threshold' : '‚ùå Coverage below required threshold - please add more tests'}`;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });
          } catch (error) {
            console.error('Error posting coverage comment:', error.message);
          }

  infrastructure:
    needs: test
    runs-on: ubuntu-latest
    if: >
      github.event_name == 'push' && 
      github.ref == 'refs/heads/main' &&
      !contains(github.event.head_commit.message, 'chore(main): release')
    environment: dev
    
    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - name: Check if Terraform files changed
      id: terraform-changes
      run: |
        if git diff --name-only HEAD~1 HEAD | grep -E '^terraform/' > /dev/null; then
          echo "changed=true" >> $GITHUB_OUTPUT
        else
          echo "changed=false" >> $GITHUB_OUTPUT
        fi
    
    - name: Skip if no Terraform changes
      if: steps.terraform-changes.outputs.changed == 'false'
      run: echo "‚è≠Ô∏è  Skipping infrastructure job - no Terraform changes detected"
    
    - name: Setup Terraform
      if: steps.terraform-changes.outputs.changed == 'true'
      uses: hashicorp/setup-terraform@v2
      with:
        terraform_version: latest
    
    - name: Create .terraformrc
      if: steps.terraform-changes.outputs.changed == 'true'
      run: |
        cat > ~/.terraformrc << EOF
        credentials "app.terraform.io" {
          token = "${{ secrets.TF_API_TOKEN }}"
        }
        EOF
    
    - name: Terraform Init and Select Dev Workspace
      if: steps.terraform-changes.outputs.changed == 'true'
      run: |
        cd terraform
        terraform init -input=false -upgrade -reconfigure
      env:
        ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
        ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
        ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
        ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
        TF_WORKSPACE: azure-pension-demo-dev
    
    - name: Terraform Plan Dev
      if: steps.terraform-changes.outputs.changed == 'true'
      run: cd terraform && terraform plan -var-file=environments/dev/terraform.tfvars -out=tfplan-dev
      env:
        ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
        ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
        ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
        ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
        TF_WORKSPACE: azure-pension-demo-dev
    
    - name: Terraform Apply Dev
      if: steps.terraform-changes.outputs.changed == 'true'
      run: cd terraform && terraform apply -auto-approve tfplan-dev
      env:
        ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
        ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
        ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
        ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
        TF_WORKSPACE: azure-pension-demo-dev

  deploy-dev:
    needs: infrastructure
    runs-on: ubuntu-latest
    if: >
      github.event_name == 'push' && 
      github.ref == 'refs/heads/main' && 
      !contains(github.event.head_commit.message, 'chore(main): release') &&
      !contains(github.head_ref, 'release-please')
    environment: dev
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: '8.0.x'
    
    - name: Restore dependencies
      run: dotnet restore src/Functions/Functions.csproj
    
    - name: Build Functions
      run: dotnet build src/Functions/Functions.csproj --configuration Release
    
    - name: Publish Functions
      run: dotnet publish src/Functions/Functions.csproj --configuration Release --output ./output
    
    - name: Deploy to Azure Functions Dev
      uses: Azure/functions-action@v1
      with:
        app-name: 'vjs-pension-dev-func-2'
        package: './output'
        publish-profile: ${{ secrets.AZURE_FUNCTIONAPP_PUBLISH_PROFILE_DEV }}

  release-please:
    needs: deploy-dev
    runs-on: ubuntu-latest
    if: >
      github.event_name == 'push' && 
      github.ref == 'refs/heads/main' && 
      !contains(github.event.head_commit.message, 'chore(main): release') &&
      needs.deploy-dev.result == 'success'
    
    steps:
      - uses: actions/checkout@v4
      
      - uses: googleapis/release-please-action@v4
        with:
          token: ${{ secrets.RELEASE_PLEASE_TOKEN }}
          release-type: simple

  deploy-prod:
    needs: test
    runs-on: ubuntu-latest
    if: >
      github.event_name == 'push' && 
      github.ref == 'refs/heads/main' && 
      contains(github.event.head_commit.message, 'chore(main): release')
    environment: prod
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: '8.0.x'
    
    - name: Restore dependencies
      run: dotnet restore src/Functions/Functions.csproj
    
    - name: Build Functions
      run: dotnet build src/Functions/Functions.csproj --configuration Release
    
    - name: Publish Functions
      run: dotnet publish src/Functions/Functions.csproj --configuration Release --output ./output
    
    - name: Deploy to Azure Functions Prod
      uses: Azure/functions-action@v1
      with:
        app-name: 'vjs-pension-prod-func-2'
        package: './output'
        publish-profile: ${{ secrets.AZURE_FUNCTIONAPP_PUBLISH_PROFILE_PROD }}

  cleanup-release-branch:
    needs: deploy-prod
    runs-on: ubuntu-latest
    if: >
      github.event_name == 'push' && 
      github.ref == 'refs/heads/main' && 
      contains(github.event.head_commit.message, 'chore(main): release') &&
      needs.deploy-prod.result == 'success'
    
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.RELEASE_PLEASE_TOKEN }}
          fetch-depth: 0
      
      - name: Delete release-please branch
        run: |
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          
          # Delete ANY branch starting with "release-please"
          echo "üîç Looking for release-please branches to delete..."
          git ls-remote --heads origin | awk '/release-please/ { print $2 }' | sed 's|refs/heads/||' | while read branch; do
            if [ ! -z "$branch" ]; then
              echo "üóëÔ∏è Deleting branch: $branch"
              git push origin --delete "$branch" || echo "‚ö†Ô∏è Could not delete $branch"
            fi
          done
          
          echo "‚úÖ Cleanup complete"
