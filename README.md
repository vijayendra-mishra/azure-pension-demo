# Azure Pension Demo - CI/CD Pipeline

This project demonstrates a complete CI/CD pipeline for .NET 8 Azure Functions with automated testing, deployment, and release management.

## ğŸ—ï¸ Project Structure

```
azure-pension-demo/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ Functions/           # Azure Functions (.NET 8 Isolated)
â”‚   â”œâ”€â”€ Application/         # Business logic layer
â”‚   â”œâ”€â”€ Domain/             # Domain entities and interfaces
â”‚   â””â”€â”€ Tests/              # Unit tests (xUnit)
â”œâ”€â”€ infra/                  # Terraform infrastructure code
â”œâ”€â”€ .github/workflows/      # GitHub Actions CI/CD pipeline
â””â”€â”€ tests/                  # Bruno API tests
```

## ğŸ”® Future Enhancements Planned

### **Database Integration**
- ğŸ³ **Docker Compose + Azure SQL Edge**: Spin up local database environments fast for development
- ğŸ—ƒï¸ **EF Core Integration**: Create entities and SQL migrations efficiently using `dotnet ef` commands
  ```bash
  dotnet ef migrations add InitialCreate
  dotnet ef database update
  ```

### **Advanced Testing**
- ğŸ§ª **Integration Tests**: TestContainers + NUnit with Docker test environments for database integration testing
- ğŸš€ **API Testing**: Bruno collections for comprehensive API endpoint testing (better than Postman for CI/CD)

### **Development Experience**
- ğŸ“¦ **One-Command Setup**: `docker-compose up` for complete local development environment
- ğŸ”„ **Hot Reload**: Database schema changes with automatic migration application
- ğŸ› **Debugging**: Full-stack debugging with containerized dependencies

## ğŸš€ CI/CD Pipeline Overview

Our pipeline implements a **GitFlow-inspired** approach with automated deployments and releases:

### Pipeline Flow

```mermaid
graph TD
    A[Feature Branch] --> B[Pull Request to Main]
    B --> C[Run Tests]
    C --> D{Tests Pass?}
    D -->|No| E[âŒ Block Merge]
    D -->|Yes| F[âœ… Allow Merge]
    F --> G[Merge to Main]
    G --> H[Run Tests Again]
    H --> I[Deploy to Dev]
    I --> J[Create Release PR]
    J --> K[Review & Merge Release]
    K --> L[Deploy to Production]
    L --> M[Generate Release Notes]
```

## ğŸ“‹ Detailed CI/CD Steps

### 1. **Pull Request Workflow**
When you create a PR from a feature branch to `main`:

- **Trigger**: Pull request opened/updated
- **Jobs**: `test` only
- **Actions**:
  1. ğŸ”„ Checkout code
  2. âš™ï¸ Setup .NET 8.0.x
  3. ğŸ“¦ Restore dependencies (`PensionDemo.sln`)
  4. ğŸ”¨ Build entire solution
  5. ğŸ§ª Run unit tests with code coverage
- **Result**: PR can only be merged if tests pass âœ…

### 2. **Development Deployment**
When you merge a PR to `main` (non-release):

- **Trigger**: Push to `main` branch (excluding release commits)
- **Jobs**: `test` â†’ `deploy-dev` â†’ `release-please`
- **Actions**:
  1. ğŸ§ª **Test Job**: Same as PR workflow
  2. ğŸš€ **Deploy to Dev**:
     - Setup .NET 8.0.x
     - Build Functions project only
     - Publish Azure Functions package
     - Deploy to Azure Functions Dev environment
  3. ğŸ“‹ **Release Management**:
     - Run release-please to analyze commits
     - Create release PR if changes warrant a release
     - Follow conventional commit standards

### 3. **Production Deployment**
When you merge a release PR to `main`:

- **Trigger**: Push to `main` with release commit message
- **Jobs**: `test` â†’ `deploy-prod`
- **Actions**:
  1. ğŸ§ª **Test Job**: Ensure quality before production
  2. ğŸ¯ **Deploy to Production**:
     - Build and publish Functions
     - Deploy to Azure Functions Production
     - Clean up release branch automatically
  3. ğŸ“ **Release Notes**: Auto-generated by release-please

## ğŸ”§ Technical Implementation

### Test Strategy
- **Solution-Level Testing**: Builds and tests the entire `PensionDemo.sln`
- **Unit Tests**: Located in `src/Tests/` project
- **Code Coverage**: Collected using XPlat Code Coverage
- **Deployment Testing**: Only Functions project is built for deployment

### Environment Configuration
- **Dev Environment**: Automatic deployment on main merge
- **Prod Environment**: Manual release workflow via release PRs
- **Secrets**: Azure publish profiles stored in GitHub secrets
  - `AZURE_FUNCTIONAPP_PUBLISH_PROFILE_DEV`
  - `AZURE_FUNCTIONAPP_PUBLISH_PROFILE_PROD`

### Release Management
- **Tool**: Google Release Please (modern `googleapis/release-please-action@v4`)
- **Versioning**: Semantic versioning based on conventional commits
- **Changelog**: Auto-generated with categorized changes
- **Branch Cleanup**: Automatic deletion of release branches after merge

## ğŸ›¡ï¸ Safety Features

### Quality Gates
- âœ… **Tests must pass** before any deployment
- âœ… **Dev deployment must succeed** before creating releases
- âœ… **No production deployment** if tests fail
- âœ… **Release branches cleaned up** automatically

### Deployment Protection
- ğŸ”’ **Environment Protection**: GitHub environments with approval rules
- ğŸ”„ **Rollback Capability**: Previous versions remain available
- ğŸ“Š **Monitoring**: Deploy status visible in GitHub Actions
- ğŸš« **Fail-Safe**: Deployments halt on any failure

## ğŸ“š Conventional Commits

Use these commit types for automatic release categorization:

- `feat:` - New features (minor version bump)
- `fix:` - Bug fixes (patch version bump)  
- `chore:` - Maintenance tasks
- `docs:` - Documentation changes
- `style:` - Code formatting
- `refactor:` - Code restructuring
- `perf:` - Performance improvements
- `test:` - Test updates
- `build:` - Build system changes
- `ci:` - CI/CD changes

### Breaking Changes
Add `!` after type or include `BREAKING CHANGE:` in footer for major version bumps:
```
feat!: redesign user authentication
```

## ğŸ® Demo Scenarios

### Scenario 1: Feature Development
```bash
# 1. Create feature branch
git checkout -b feature/add-pension-calculation

# 2. Make changes, commit with conventional format
git commit -m "feat: add pension calculation endpoint"

# 3. Push and create PR
git push origin feature/add-pension-calculation
# Create PR on GitHub â†’ Tests run automatically

# 4. Merge PR â†’ Auto-deploy to dev + create release PR
```

### Scenario 2: Production Release
```bash
# 1. Review and merge the auto-created release PR
# 2. Automatic production deployment triggers
# 3. Release notes generated automatically
# 4. Release branch cleaned up
```

## ğŸ” Monitoring & Troubleshooting

### Pipeline Status
- **GitHub Actions**: View real-time pipeline status
- **Environment Deployments**: Track dev/prod deployment history
- **Release History**: See all releases and their changelogs

### Common Issues
1. **Test Failures**: Check unit test output in GitHub Actions logs
2. **Deployment Failures**: Verify Azure publish profiles are valid
3. **Release PR Not Created**: Ensure conventional commit format is used
4. **Branch Cleanup**: Verify GitHub repo settings allow branch deletion

## ğŸš€ Getting Started

1. **Clone Repository**: `git clone <repo-url>`
2. **Install .NET 8**: Download from Microsoft
3. **Setup Azure**: Configure function apps and get publish profiles
4. **Configure Secrets**: Add publish profiles to GitHub repository secrets
5. **Enable Settings**: Turn on "Automatically delete head branches" in repo settings
6. **Start Developing**: Create feature branches and follow conventional commits

---

**This pipeline provides a production-ready CI/CD solution with automatic testing, deployment, and release management for Azure Functions applications.** ğŸ‰

This project demonstrates a **modern CI/CD pipeline** for a C# Azure Functions app with automated testing, deployment, and release management.

## ğŸ—ï¸ Architecture Overview
- **Azure Functions (C#)**: API endpoints for pension operations (.NET 8)
- **EF Core + Azure SQL**: Data persistence layer
- **Mediatr**: CQRS pattern for clean architecture
- **Terraform Cloud**: Infrastructure as Code (IaC)
- **GitHub Actions**: Automated CI/CD pipeline
- **Release-Please**: Automated semantic versioning and releases

## ğŸš€ CI/CD Pipeline Demo

### Pipeline Flow Visualization
```
Feature Branch â†’ PR â†’ Tests â†’ Merge â†’ Deploy Dev â†’ Release PR â†’ Deploy Prod
     â†“           â†“      â†“        â†“         â†“           â†“          â†“
   Code Dev   Run Tests Only  Auto Deploy  Create    Manual    Auto Deploy
                             to Dev Env   Release   Approval   to Prod Env
```

### Detailed Pipeline Steps

#### 1. **Pull Request Workflow**
**Trigger**: Opening PR from `feature/*` to `main`
```yaml
# What happens:
âœ… Checkout code
âœ… Setup .NET 8
âœ… Restore dependencies  
âœ… Build application
âœ… Run unit tests
âŒ NO deployment (testing only)
```

#### 2. **Development Deployment**
**Trigger**: Merging feature branch to `main` (non-release commits)
```yaml
# Sequential execution:
âœ… Run all tests (must pass)
âœ… Build for Release
âœ… Deploy to Azure Functions Dev Environment
âœ… Create Release PR (via release-please)
```

#### 3. **Production Deployment** 
**Trigger**: Merging release PR to `main` (release commits)
```yaml
# What happens:
âœ… Run all tests (must pass)
âœ… Build for Release  
âœ… Deploy to Azure Functions Prod Environment
âœ… Auto-delete release branch (cleanup)
âœ… Generate release notes
```

## ğŸ”§ Pipeline Configuration

### GitHub Secrets Required
```bash
# Azure Function App Publish Profiles
AZURE_FUNCTIONAPP_PUBLISH_PROFILE_DEV   # Dev environment
AZURE_FUNCTIONAPP_PUBLISH_PROFILE_PROD  # Production environment
```

### Environment Detection
The pipeline automatically detects deployment target:
- **Dev Deploy**: `!contains(commit.message, 'chore(main): release')`
- **Prod Deploy**: `contains(commit.message, 'chore(main): release')`

### Safety Features
- âœ… **Tests must pass** before any deployment
- âœ… **Dev deployment must succeed** before creating release PR  
- âœ… **No releases created** if pipeline fails
- âœ… **Automatic branch cleanup** after successful deployment

## ğŸ“‹ Demo Script

### Step 1: Feature Development
```bash
# Create feature branch
git checkout -b feature/demo-enhancement
# Make code changes...
git commit -m "feat: add new pension calculation feature"
git push origin feature/demo-enhancement
```
**Result**: Creates PR â†’ Triggers test-only pipeline

### Step 2: Code Review & Merge
```bash
# Create PR via GitHub UI
# Review code, approve PR
# Merge PR to main
```
**Result**: Triggers dev deployment â†’ Creates release PR automatically

### Step 3: Release to Production
```bash
# Review generated release PR
# Merge release PR to main  
```
**Result**: Triggers prod deployment â†’ Creates release notes â†’ Cleans up branches

## ğŸ› ï¸ Local Development

### Quick Start
```bash
# 1. Start local database
docker-compose up -d

# 2. Run Azure Functions locally
cd src/Functions
func start

# 3. Test endpoints
curl http://localhost:7071/api/pensions
```

### Project Structure
```
â”œâ”€â”€ .github/workflows/     # CI/CD pipeline definitions
â”‚   â””â”€â”€ ci-cd.yml         # Main pipeline workflow
â”œâ”€â”€ src/                  # Application source code
â”‚   â””â”€â”€ Functions/        # Azure Functions project
â”œâ”€â”€ infra/                # Terraform infrastructure code
â”œâ”€â”€ release-please-config.json    # Release automation config
â””â”€â”€ .release-please-manifest.json # Version tracking
```

## ğŸ” Pipeline Monitoring

### View Pipeline Status
1. **GitHub Actions Tab**: See all workflow runs
2. **PR Checks**: View test results on pull requests  
3. **Deployments Tab**: Monitor environment deployments
4. **Releases**: Track automated releases

### Common Pipeline States
- ğŸŸ¢ **All Green**: Tests pass, deployment successful
- ğŸŸ¡ **In Progress**: Pipeline currently running
- ğŸ”´ **Failed**: Check logs for specific failure point
- âšª **Skipped**: Conditional job not triggered

## ğŸ¯ Key Benefits Demonstrated

### Developer Experience
- **Zero-config deployments**: Just merge to main
- **Automated testing**: Catch issues before deployment
- **Safe releases**: Only deploy working code
- **Clean history**: Automated release notes and versioning

### Operations Benefits  
- **Environment parity**: Same deployment process for dev/prod
- **Rollback ready**: Tagged releases for easy rollbacks
- **Audit trail**: Complete deployment history in GitHub
- **Branch hygiene**: Automatic cleanup prevents branch sprawl

## ğŸš¨ Troubleshooting

### Pipeline Failures
```bash
# Check workflow logs
GitHub â†’ Actions â†’ Click failed workflow â†’ View logs

# Common issues:
âŒ Test failures â†’ Fix code, push to feature branch
âŒ Deploy failures â†’ Check Azure secrets configuration  
âŒ Release failures â†’ Verify release-please configuration
```

### Environment Issues
```bash
# Dev deployment failed
â†’ Check AZURE_FUNCTIONAPP_PUBLISH_PROFILE_DEV secret

# Prod deployment failed  
â†’ Check AZURE_FUNCTIONAPP_PUBLISH_PROFILE_PROD secret
```

```

---

## ğŸ¢ Enterprise Infrastructure Considerations

### Current Architecture: Shared App Service Plan
This demo uses a **shared App Service Plan** for cost efficiency:
```
âœ… 1 Shared App Service Plan (B1 Basic)
âœ… 2 Function Apps (dev + prod) 
âœ… Separate storage accounts per environment
âœ… Separate Application Insights per environment
```

### Enterprise Scaling Patterns

#### **When Shared Plans Work Well:**
- âœ… **Dev/Test environments** - Cost optimization priority
- âœ… **Same team/application** - Similar governance needs
- âœ… **Internal APIs** - Lower isolation requirements
- âœ… **Complementary workloads** - Different peak usage times

#### **When to Use Dedicated Plans:**
- âŒ **Production workloads** - SLA and performance guarantees
- âŒ **Different business units** - Billing isolation requirements
- âŒ **Regulatory compliance** - SOX, HIPAA, PCI DSS isolation
- âŒ **Customer-facing apps** - Blast radius concerns

### **Enterprise Migration Path:**

```terraform
# Phase 1: Demo/Learning (Current)
resource "azurerm_service_plan" "shared_basic" {
  name     = "pension-shared-plan"
  sku_name = "B1"    # Basic shared for cost
}

# Phase 2: Pre-Production 
resource "azurerm_service_plan" "preprod_shared" {
  name     = "pension-preprod-shared-plan"
  sku_name = "S1"    # Standard shared
}

# Phase 3: Production (Enterprise)
resource "azurerm_service_plan" "prod_dedicated" {
  name     = "pension-prod-plan"  
  sku_name = "P1v3"  # Premium dedicated
}

# Phase 4: Enterprise Scale
resource "azurerm_service_plan" "prod_premium" {
  name     = "pension-prod-plan"
  sku_name = "EP1"   # Elastic Premium
  # + VNet integration
  # + Private endpoints  
  # + Multi-region deployment
}
```

### **Enterprise Best Practices:**
- ğŸ¯ **Tier 1 (Production)**: Dedicated Premium plans with VNet integration
- ğŸ¯ **Tier 2 (Pre-Prod)**: Shared Standard plans within same environment
- ğŸ¯ **Tier 3 (Development)**: Highly shared Basic plans for cost efficiency

---

## ğŸ¬ Live Demo Ready!

This pipeline demonstrates **modern DevOps practices** with:
- âœ… Automated testing and deployment
- âœ… Environment promotion strategy  
- âœ… Semantic versioning and releases
- âœ… Safety checks and rollback capabilities
- âœ… Branch management and cleanup

**Perfect for showcasing CI/CD best practices in Azure!** ğŸš€